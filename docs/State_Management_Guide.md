# AI-GF 상태 관리 가이드

이 문서는 AI-GF 프로젝트에서 사용되는 세 가지 주요 상태 관리 도구(`electron-store`, `AppContext`, `ContextStore`)의 역할과 책임, 그리고 올바른 사용법을 정의합니다.

**이 가이드의 목표는 개발의 일관성을 확보하고, 데이터 흐름을 예측 가능하게 만들며, 장기적인 유지보수 비용을 줄이는 것입니다. 모든 개발자는 이 가이드를 숙지하고 준수해야 합니다.**

## 1. 핵심 원칙: 최소 범위 우선 (Principle of Least Scope)

상태를 관리하는 도구를 선택할 때 가장 중요한 원칙은 **"필요한 가장 작은 유효 범위(Scope)를 갖는 도구를 선택하는 것"**입니다. 전역적인 상태는 추적과 디버깅을 어렵게 만듭니다. 항상 가장 제한적인 범위의 상태부터 고려하고, 꼭 필요한 경우에만 더 넓은 범위의 도구를 사용해야 합니다.

## 2. 상태 관리 도구 상세

### 가. `electron-store`: 영속적인 사용자 설정

-   **무엇인가?**: 사용자의 하드 드라이브(`config.json` 파일)에 데이터를 저장하는 영속성(Persistence) 저장소입니다. 메인 프로세스가 데이터의 소유자이며, IPC 통신을 통해서만 안전하게 접근할 수 있습니다.
-   **핵심 특징**:
    -   **유효 범위**: 애플리케이션 전역 (메인 + 렌더러 프로세스)
    -   **생명 주기**: **영속적.** 앱을 종료하거나 재시작해도 데이터가 유지됩니다.
    -   **데이터 타입**: JSON으로 직렬화 가능한 데이터만 저장할 수 있습니다 (문자열, 숫자, 배열, 간단한 객체 등). 함수나 클래스 인스턴스는 저장할 수 없습니다.
    -   **성능**: 디스크 I/O가 발생하므로, 세 도구 중 가장 느립니다. 빈번하게 수정되는 데이터에는 적합하지 않습니다.

-   **주요 사용 사례 (When to use):**
    -   사용자가 설정하고 앱을 재시작해도 유지되어야 하는 모든 값.
    -   API 키, 언어 설정, 창 크기 및 위치, 볼륨 설정 등.
    -   사용자가 마지막으로 로드한 VRM 파일 경로.

-   **사용하면 안 되는 경우 (When NOT to use):**
    -   앱 실행 중에만 유효한 임시 데이터 (예: 현재 캐릭터의 감정 상태).
    -   빠르게, 자주 변경되는 런타임 상태 값.
    -   함수, 클래스 인스턴스 등 복잡한 JavaScript 객체.

### 나. `AppContext` (React Context API): 렌더러의 UI 상태와 핵심 모듈

-   **무엇인가?**: React의 내장 기능으로, 컴포넌트 트리 전체에 데이터를 효율적으로 전달하는 방법입니다. 렌더러 프로세스(UI) 내에서만 존재합니다.
-   **핵심 특징**:
    -   **유효 범위**: React 컴포넌트 트리 (렌더러 프로세스 한정)
    -   **생명 주기**: **인-메모리(In-Memory).** 페이지를 새로고침하거나 앱을 재시작하면 초기화됩니다.
    -   **데이터 타입**: 모든 JavaScript 데이터를 저장할 수 있습니다 (함수, 클래스 인스턴스, 상태 관리 로직 등).
    -   **성능**: 메모리에서 직접 접근하므로 매우 빠릅니다. 단, Context 값이 변경되면 이를 구독하는 모든 컴포넌트가 리렌더링될 수 있으므로 주의해야 합니다.

-   **주요 사용 사례 (When to use):**
    -   `vrmManager`, `pluginManager`, `actionRegistry`와 같이 애플리케이션의 핵심적인 관리자(Manager) 인스턴스를 생성하고, 모든 UI 컴포넌트가 접근할 수 있도록 제공할 때. (의존성 주입)
    -   '편집 모드' 활성화 여부, 특정 패널의 열림/닫힘 상태와 같이 여러 컴포넌트에 걸쳐 공유되는 UI 상태를 관리할 때.

-   **사용하면 안 되는 경우 (When NOT to use):**
    -   앱을 재시작해도 유지되어야 하는 데이터 (-> `electron-store` 사용).
    -   플러그인이나 모드와 같이 React 컴포넌트가 아닌 시스템과 상태를 공유해야 할 때 (-> `ContextStore` 사용).

### 다. `ContextStore`: 플러그인과 모드를 위한 공유 메모리

-   **무엇인가?**: 렌더러 프로세스 내에서 전역적으로 접근 가능한, 간단한 인-메모리 키-값(Key-Value) 저장소입니다.
-   **핵심 특징**:
    -   **유효 범위**: 렌더러 프로세스 전역 (React 컴포넌트, 플러그인, 모드 모두 접근 가능)
    -   **생명 주기**: **인-메모리(In-Memory).** 페이지를 새로고침하거나 앱을 재시작하면 초기화됩니다.
    -   **데이터 타입**: 모든 타입을 저장할 수 있지만, 시스템 간의 간단한 상태 공유를 위해 **원시 타입(string, number, boolean) 사용을 강력히 권장**합니다.
    -   **성능**: 단순한 Map 객체이므로 매우 빠릅니다.

-   **주요 사용 사례 (When to use):**
    -   **플러그인/모드 간의 상태 공유**: 한 플러그인에서 발생한 상태를 다른 플러그인에서 사용해야 할 때. (예: `ProactiveDialoguePlugin`이 마지막 대화 시간을 `lastSpokenTimestamp` 키로 저장하면, 다른 플러그인이 이 값을 읽어 특정 행동을 결정할 수 있음)
    -   **플러그인/모드와 UI 간의 상태 공유**: 플러그인이 자신의 내부 상태(예: '현재 바쁜 상태임')를 `isBusy` 키로 저장하면, `ContextStoreDebugPanel`과 같은 UI가 이 값을 표시할 수 있습니다.
    -   `Trigger`의 `condition` 함수에서 참조해야 하는 동적인 런타임 상태 값.

-   **사용하면 안 되는 경우 (When NOT to use):**
    -   앱을 재시작해도 유지되어야 하는 데이터 (-> `electron-store` 사용).
    -   핵심 관리자 모듈이나 UI 상태를 컴포넌트 트리에 전달할 때 (-> `AppContext` 사용).

## 3. 빠른 비교표

| 특징             | `electron-store`                  | `AppContext` (React Context)      | `ContextStore`                      |
| :--------------- | :-------------------------------- | :-------------------------------- | :---------------------------------- |
| **주요 목적**    | **영속적인 사용자 설정**          | **UI 상태 및 핵심 모듈 주입**     | **플러그인/모드 간의 상태 공유**    |
| **유효 범위**    | 앱 전역 (메인 + 렌더러)           | React 컴포넌트 트리 (렌더러)      | 렌더러 프로세스 전역                |
| **생명 주기**    | **영속적 (디스크)**               | 인-메모리 (새로고침 시 초기화)    | 인-메모리 (새로고침 시 초기화)      |
| **데이터 타입**  | JSON 직렬화 가능                  | 모든 타입                         | 모든 타입 (원시 타입 권장)          |
| **성능**         | 느림 (디스크 I/O)                 | 빠름 (메모리)                     | 빠름 (메모리)                       |
| **데이터 소유자**| 메인 프로세스                     | React 렌더러                      | 렌더러 (전역)                       |
| **접근 방식**    | IPC 통신 (`window.electronAPI`)   | `useAppContext()` 훅              | `pluginContext.contextStore`        |

## 4. 의사결정 흐름도: 어떤 도구를 써야 할까?

새로운 상태 값을 저장해야 할 때, 아래의 질문을 순서대로 따라가세요.

**질문 1: 이 데이터는 앱을 껐다 켜도 유지되어야 하는가?**
-   **예** -> **`electron-store`** 를 사용하세요. (더 이상 고민할 필요 없음)
-   **아니오** -> 질문 2로 이동하세요.

**질문 2: 이 데이터는 `vrmManager`와 같은 핵심 모듈이거나, 여러 React 컴포넌트에 걸쳐 공유되는 "UI 상태"인가?**
-   **예** -> **`AppContext`** 를 사용하세요.
-   **아니오** -> 질문 3으로 이동하세요.

**질문 3: 이 데이터는 플러그인/모드 간에 공유되거나, 플러그인의 내부 상태를 외부(다른 플러그인, UI)에 알리기 위한 것인가?**
-   **예** -> **`ContextStore`** 를 사용하세요.
-   **아니오** -> 이 데이터는 특정 컴포넌트나 모듈 내부에서만 사용될 가능성이 높습니다. `useState`나 클래스 속성 등 지역적인 상태로 관리하는 것을 우선 고려하세요.
