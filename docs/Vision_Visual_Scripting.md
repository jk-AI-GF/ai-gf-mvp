# 비전: 노드 기반 비주얼 스크립팅 시스템 "시퀀스"

이 문서는 AI-GF 프로젝트가 나아갈 차세대 상호작용 제작 시스템의 비전과 개발 계획을 기술합니다. 이 문서는 프로젝트의 공식적인 목표 선언서이며, 모든 관련 개발은 이 비전에 부합해야 합니다.

## 1. 비전: 사용자를 '관객'에서 '연출가'로

현재의 AI 캐릭터는 개발자가 미리 정의한 한정된 상호작용만 수행할 수 있습니다. 우리의 최종 목표는 이 한계를 부수고, 사용자를 단순히 캐릭터를 감상하는 '관객'에서, 캐릭터의 모든 행동과 상호작용을 직접 설계하고 연출하는 **'창조자(Creator)'이자 '연출가(Director)'**로 만드는 것입니다.

이를 위해, 우리는 코딩 지식이 없는 사용자도 직관적으로 복잡한 로직을 만들 수 있는 **노드 기반의 비주얼 스크립팅 시스템, "시퀀스(Sequence)"**를 도입합니다. 사용자는 이 시스템을 통해 자신만의 캐릭터 성격, 일과, 대화 시나리오를 창조하고, 이를 다른 사용자와 쉽게 공유하며 하나의 거대한 창작 생태계를 형성하게 될 것입니다.

## 2. 핵심 개념

### 가. 시퀀스 (Sequence)
'시퀀스'는 하나의 완전한 상호작용 로직을 담고 있는 노드 그래프입니다. 이것은 사용자가 만들고, 저장하고, 공유하는 콘텐츠의 기본 단위가 됩니다. (예: '아침 인사 시퀀스', '사용자 칭찬에 반응하는 시퀀스')

### 나. 노드 (Node)
노드는 시퀀스를 구성하는 가장 작은 기능 단위입니다. 사용자는 시퀀스 에디터에서 이 노드들을 끌어다 놓고 선으로 연결하여 로직을 조립합니다. 주요 노드 타입은 다음과 같습니다.

-   **이벤트 노드 (Event Node)**: 시퀀스의 시작점입니다. "사용자가 채팅을 쳤을 때"(`OnChatMessage`)나 "30초가 지났을 때"(`OnTimer`)와 같이 특정 사건의 발생을 감지하여 연결된 다음 노드를 실행시킵니다.
-   **액션 노드 (Action Node)**: 실제 동작을 수행하는 노드입니다. "애니메이션 재생", "TTS 말하기", "표정 바꾸기" 등 `Actions API`에 등록된 모든 행동이 액션 노드가 될 수 있습니다.
-   **제어 흐름 노드 (Control Flow Node)**: 로직의 흐름을 제어합니다. "만약 ~라면"(Branch), "N번 반복"(For Loop), "지연"(Delay) 등이 포함됩니다.
-   **데이터 노드 (Data Node)**: 데이터를 생성하거나, 가져오거나, 가공합니다. "사용자 이름 가져오기", "숫자 10", "두 숫자를 더하기" 등이 여기에 해당합니다.

### 다. 데이터 흐름 (Data Flow)
단순히 노드를 순서대로 실행하는 것을 넘어, 한 노드의 결과값(출력)을 다른 노드의 필요값(입력)으로 연결하는 개념입니다. 예를 들어, '사용자 이름 가져오기' 노드의 출력(문자열 "홍길동")을 'TTS 말하기' 노드의 입력(말할 내용)으로 연결하여 "안녕하세요, 홍길동님!"이라고 말하게 만들 수 있습니다. 이것이 시퀀스 시스템의 핵심적인 강력함입니다.

### 라. 노드의 내부 구조: 클래스 상속 모델
견고하고 확장 가능한 시스템을 구축하기 위해, 모든 노드는 공통의 `BaseNode` 클래스를 상속받는 객체 지향 모델을 따릅니다.

-   **`BaseNode` (기본 클래스)**: 모든 노드가 가져야 할 공통 속성(ID, 이름, 위치, 입/출력 포트 목록 등)과 기능(직렬화/역직렬화 등)을 정의합니다. 가장 중요한 것은 모든 자식 클래스가 반드시 구현해야 하는 `execute()` 추상 메소드입니다.

-   **구체적인 노드 (자식 클래스)**: `BaseNode`를 상속받아 각자의 특화된 `execute()` 로직을 구현합니다.
    -   `ActionNode`: `execute()`가 호출되면 `PluginContext`의 `actions` API를 실행합니다.
    -   `BranchNode`: `execute()`가 호출되면 입력 데이터를 평가하여 `True` 또는 `False` 실행 출력 포트로 신호를 보냅니다.

이러한 구조는 코드 재사용성을 극대화하고, 새로운 노드 타입을 쉽게 추가할 수 있게 하며, '시퀀스 엔진'이 모든 노드를 `BaseNode`라는 단일 타입으로 간주하고 `execute()`만 호출하면 되는 다형성의 이점을 제공하여 엔진의 복잡도를 크게 낮춥니다.

## 3. 핵심 설계 원칙

모든 관련 기능 개발 시 다음 원칙을 반드시 준수해야 합니다.

1.  **직관성 (Intuitive for Non-Programmers)**: 모든 UI와 용어는 프로그래밍 경험이 없는 사용자도 쉽게 이해하고 사용할 수 있도록 설계되어야 합니다.
2.  **확장성 (Extensible for Power Users)**: 숙련된 사용자가 커스텀 액션이나 이벤트를 추가하여 시스템의 기능을 확장할 수 있는 구조를 지향해야 합니다.
3.  **시각적 디버깅 (Visually Debuggable)**: 시퀀스가 실행될 때, 현재 어떤 노드가 실행 중인지, 노드 간에 어떤 데이터가 오고 가는지 시각적으로 확인할 수 있어야 합니다.
4.  **재사용성 (Reusable)**: 잘 만들어진 시퀀스는 다른 시퀀스 내부에서 하나의 노드(함수)처럼 호출하여 재사용할 수 있어야 합니다.

## 4. 개발 로드맵

(이전 답변과 동일)

## 5. 레거시가 될 아키텍처

(이전 답변과 동일)

## 6. 기술 스택 결정: 왜 React Flow인가?

이 비전을 구현하기 위한 핵심 라이브러리로 `React Flow`를 선택합니다. 다른 대안(`Rete.js`, `LiteGraph.js` 등)도 검토되었으나, 다음과 같은 이유로 `React Flow`가 우리 프로젝트에 가장 적합하다고 판단합니다.

-   **React 네이티브**: 현재 프로젝트의 기술 스택인 React와 완벽하게 통합됩니다. 컴포넌트 기반으로 커스텀 노드를 쉽게 만들 수 있으며, React의 생명주기와 상태 관리를 자연스럽게 활용할 수 있습니다.
-   **높은 자유도와 유연성**: `React Flow`는 UI 렌더링에 집중하는 라이브러리(Library)입니다. 이는 우리가 원하는 대로 **'시퀀스 엔진'의 실행 로직과 데이터 흐름을 완벽하게 제어**하고, 기존 `Actions API` 및 `EventBus`와 깊게 통합할 수 있음을 의미합니다. 프레임워크(Framework)에 갇히지 않는 유연성이 가장 큰 장점입니다.
-   **활발한 커뮤니티와 유지보수**: 라이브러리가 지속적으로 업데이트되고 있으며, 방대한 예제와 커뮤니티 지원을 받을 수 있습니다. 이는 개발 과정에서 마주할 문제들을 해결하는 데 큰 도움이 됩니다.

`Rete.js`와 같은 프레임워크는 자체 데이터 흐름 엔진을 내장하고 있어 개발이 편할 수 있지만, 우리 프로젝트의 독자적인 아키텍처와 충돌할 가능성이 있고, 불필요한 제약을 만들 수 있어 채택하지 않았습니다. `React Flow`는 우리에게 필요한 모든 시각적 기능을 제공하면서도, 핵심 로직의 통제권은 우리에게 남겨주는 최적의 균형을 제공합니다.
