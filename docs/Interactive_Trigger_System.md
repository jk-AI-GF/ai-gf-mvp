# 대화형 트리거 시스템 (Interactive Trigger System) 설계 문서

이 문서는 사용자가 UI를 통해 직접 캐릭터의 행동 규칙을 만들 수 있는 '대화형 트리거 시스템'의 비전, 설계, 그리고 구현 로드맵을 정의합니다.

## 1. 시스템 목표 (Vision)

이 시스템의 최종 목표는 사용자를 수동적인 '관객'에서 능동적인 **'연출가'이자 '작가'**로 만드는 것입니다. 사용자는 코딩 지식 없이도, UI 조작만으로 캐릭터의 성격, 반응, 하루 일과, 심지어 간단한 게임 로직까지 직접 창조할 수 있게 됩니다.

이를 통해 우리는 개발자가 제공하는 기능의 한계를 넘어, **사용자들이 직접 콘텐츠를 만들고 공유하는 살아있는 생태계**를 구축하고자 합니다.

## 2. 핵심 개념 (Core Concepts)

### 가. 트리거의 데이터화 (Trigger as Data)

모든 트리거는 실행 가능한 '코드'가 아닌, 쉽게 저장하고 편집할 수 있는 '데이터'(주로 JSON 형식)로 표현됩니다. 이는 사용자가 만든 규칙을 파일로 저장하고, 다른 사람과 공유하는 것을 가능하게 합니다.

**예시 JSON 구조:**
```json
{
  "id": "morning_greeting_trigger",
  "name": "아침 인사하기",
  "enabled": true,
  "conditions": [
    {
      "type": "timeOfDay",
      "params": { "from": "07:00", "to": "10:00" }
    }
  ],
  "actions": [
    {
      "type": "speak",
      "params": { "text": "좋은 아침이에요!" }
    }
  ]
}
```

### 나. 조건(Condition)과 행동(Action)의 분리

모든 트리거는 **"만약 ~라면 (조건), ~를 한다 (행동)"**는 명확한 구조를 가집니다.

-   **조건 (Conditions)**: 트리거가 언제 실행되어야 하는지를 정의합니다. `EventBus`에서 발생하는 모든 이벤트(예: `chat:newMessage`)나 시스템의 특정 상태(예: `시간이 7시인가?`)가 조건이 될 수 있습니다.
-   **행동 (Actions)**: 조건이 모두 충족되었을 때 실행될 내용입니다. `Actions API`에서 제공하는 모든 기능(예: `playAnimation`, `setExpression`)이 행동이 될 수 있습니다.

### 다. UI 기반의 로우코드(Low-code) 편집 환경

사용자는 텍스트 코드를 직접 작성하는 대신, 그래픽 UI를 통해 트리거를 조립합니다.

-   **조건 편집기**: 드롭다운 메뉴에서 `EventBus` 이벤트 목록을 선택하고, 필요한 파라미터를 입력 필드에 채워 넣는 방식입니다.
-   **행동 편집기**: 드롭다운 메뉴에서 `Actions API` 목록을 선택하고, 필요한 파라미터를 채워 넣는 방식입니다.

## 3. 사용자 시나리오 (Use Cases)

이 시스템을 통해 다음과 같은 창의적인 활동이 가능해집니다.

-   **세심한 반응 패턴 설계**: "고마워"라고 말하면 웃고, 머리를 쓰다듬으면 부끄러워하는 등 사용자의 입력에 섬세하게 반응하는 캐릭터를 만들 수 있습니다.
-   **현실 시간 연동**: 아침/점심/저녁 시간에 맞춰 다른 인사를 하거나, 특정 요일에 특별한 대사를 하는 등 현실 세계와 연동된 행동 패턴을 부여할 수 있습니다.
-   **사용자 제작 미니 게임**: `ContextStore` API를 게임의 '플래그'처럼 활용하여, 특정 단어를 말하면 시작되는 간단한 퀴즈나 분기형 스토리를 만들 수 있습니다.

## 4. 구현 로드맵 (Implementation Roadmap)

이 시스템은 여러 단계에 걸쳐 점진적으로 개발됩니다.

### 1단계: 데이터 구조 및 스키마 정의 (Phase 1: Data Schema)

-   **목표**: 조건과 행동을 표현하기 위한 JSON 구조를 확정하고, 이를 검증할 수 있는 JSON Schema를 설계합니다.
-   **세부 작업**:
    -   `EventBus`의 모든 이벤트를 조건으로 변환할 때 필요한 `type`과 `params` 구조를 정의합니다.
    -   `Actions API`의 모든 함수를 행동으로 변환할 때 필요한 `type`과 `params` 구조를 정의합니다.
    -   이 구조를 바탕으로 `schemas/trigger.schema.json` 파일을 작성합니다.

### 2단계: 핵심 엔진 업그레이드 (Phase 2: Engine Upgrade)

-   **목표**: `TriggerEngine`이 코드 기반 트리거 대신, 1단계에서 정의한 JSON 데이터 기반 트리거를 해석하고 실행할 수 있도록 업그레이드합니다.
-   **세부 작업**:
    -   `trigger-loader.ts`를 만들어, `userdata/triggers/` 폴더에서 모든 `.json` 파일을 읽어 `TriggerEngine`에 등록하는 기능을 구현합니다.
    -   `TriggerEngine`의 `update` 로직을 수정하여, 등록된 JSON 트리거의 `conditions`를 매 프레임 검사하고, 충족 시 `actions`를 실행하도록 변경합니다.
    -   각 `condition.type`과 `action.type`에 맞는 실행 로직을 `TriggerEngine` 내부에 구현합니다.

### 3단계: UI 구현 (Phase 3: User Interface)

-   **목표**: 사용자가 트리거를 시각적으로 생성하고 편집할 수 있는 `TriggerEditorPanel.tsx`를 개발합니다.
-   **세부 작업**:
    -   트리거 목록 (생성/수정/삭제) UI를 구현합니다.
    -   '조건 추가/삭제' 기능과 각 조건을 편집하는 UI (드롭다운, 입력 필드)를 구현합니다.
    -   '행동 추가/삭제' 기능과 각 행동을 편집하는 UI를 구현합니다.
    -   UI의 상태가 변경될 때, 실시간으로 JSON 미리보기를 생성하여 보여주는 기능을 추가합니다.

### 4단계: 파일 입출력 연동 (Phase 4: File I/O)

-   **목표**: `TriggerEditorPanel`에서 만든 트리거를 실제 파일로 저장하고, 기존 파일을 불러와 편집할 수 있도록 시스템을 완성합니다.
-   **세부 작업**:
    -   '저장' 버튼 클릭 시, 현재 UI 상태를 기반으로 JSON 파일을 생성하고 `electronAPI`를 통해 파일 저장 대화상자를 호출하는 기능을 구현합니다.
    -   '불러오기' 버튼 클릭 시, 파일 열기 대화상자를 통해 JSON 파일을 선택하고, 그 내용을 파싱하여 `TriggerEditorPanel`의 UI 상태를 복원하는 기능을 구현합니다.
